# インターフェース（トレイト）
- トレイトを使用すると、共通の振る舞いを抽象的に定義できます。
- トレイト境界を使用すると、 あるジェネリックが、特定の振る舞いをもつあらゆる型になり得ることを指定できます。
- ※トレイトは他の言語でよくインターフェイスと呼ばれる機能に類似している。

- トレイト定義は、メソッドをあるグループにまとめ、なんらかの振る舞いを定義する
```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```
- メソッドの後に、波括弧内に実装を提供する代わりに、セミコロンを使用
- トレイトを実装する型はそれぞれ、メソッドの本体に独自の振る舞いを実装する必要がある
```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
```
- 型にトレイトを実装することは、普通のメソッドを実装することに似ています。
- 違いは、implの後に、 実装したいトレイトの名前を置き、それからforキーワード、さらにトレイトの実装対象の型の名前を指定することです。 
- implブロック内に、トレイト定義で定義したメソッドシグニチャを置きます。

トレイトは、 他のクレートが実装するためには、公開トレイトである必要がある
外部のトレイトを外部の型に対して実装することはできません。
例として、 aggregatorクレート内でVec<T>に対してDisplayトレイトを実装することはできません。 
 この制限は、コヒーレンス(coherence)、特に孤児のルール(orphan rule)と呼ばれるプログラムの特性
この規則により、他の人のコードが自分のコードを壊したり、 その逆が起きないことを保証してくれます。

## デフォルト実装

時として、全ての型の全メソッドに対して実装を要求するのではなく、トレイトの全てあるいは一部のメソッドに対して
デフォルトの振る舞いがあると有用です。 
そうすれば、特定の型にトレイトを実装する際、各メソッドのデフォルト実装を保持するかオーバーライドするか選べるわけです。





