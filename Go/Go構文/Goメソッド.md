>https://zenn.dev/sharefull_blog/articles/1fb628d82ed79b#%E3%83%9D%E3%82%A4%E3%83%B3%E3%82%BF%E3%81%A8%E3%81%AF
>[関数(複数戻り値, 名前付き戻り値, 可変長引数, 高階関数, 再帰関数)](https://www.wakuwakubank.com/posts/778-go-func/)

Table of Contents
=================

- [Table of Contents](#table-of-contents)
- [基本](#基本)
	- [複数戻り値](#複数戻り値)
	- [名前付き戻り値](#名前付き戻り値)
	- [可変長引数](#可変長引数)
- [メソッド内から構造体のフィールドにアクセス](#メソッド内から構造体のフィールドにアクセス)
	- [フィールドの値を直接操作するメソッド(ポインターレシーバ)](#フィールドの値を直接操作するメソッドポインターレシーバ)
		- [このケースでのGo言語の場合](#このケースでのgo言語の場合)

# 基本
```go
func func1(x int) string {
	return fmt.Sprint("hello world '", x, "'.")
}

func main() {
	fmt.Println(func1(1234))
	fmt.Println(func1(5678))
}
```
>出力
```
hello world '1234'.
hello world '5678'.
```

## 複数戻り値
```go
...
func func2(x, y int) (int, int) {
	return x + y, x - y
}

func main() {
	x, y := func2(10, 5)
	fmt.Println(x)
	fmt.Println(y)
}
```
>出力
```
15
5
```
## 名前付き戻り値
以下例では、add sub という名前付き戻り値で値を返しています。
```go
func func3(x, y int) (add, sub int) {
	add = x + y
	sub = x - y
	return
}

func main() {
	x, y := func3(10, 5)
	fmt.Println(x) --> 15
	fmt.Println(y) --> 5
}
```
## 可変長引数
... の記法で可変長引数を実装できます。
```go
func func4(i ...int) int {
	fmt.Println("-----------------")
	fmt.Println(i)
	sum := 0
	for _, v := range i {
		sum += v
	}
	return sum
}

func main() {
	fmt.Println(func4())
	fmt.Println(func4(1))
	fmt.Println(func4(1, 2))
	fmt.Println(func4(1, 2, 3))

	s := []int{1, 2, 3, 4}
	fmt.Println(func4(s...))

}
```
>出力
```
-----------------
[]
0
-----------------
[1]
1
-----------------
[1 2]
3
-----------------
[1 2 3]
6
-----------------
[1 2 3 4]
10
```
# メソッド内から構造体のフィールドにアクセス
```go
func (レシーバ変数 レシーバの型) メソッド名(引数1 型1, 引数2 型2, ...) 戻り値の型 {
    // メソッドの処理
    レシーバ変数.フィールド名
    hanako.Greet() // メソッドの呼び出し
}
```
## フィールドの値を直接操作するメソッド(ポインターレシーバ)

```go
func (p Person) Eat() {
	p.weight += 1
}
>>> これだと、weightの値は変わらない
```
```go
func (p *Person) Eat() {
    p.weight += 1
}
>>> これだと、weightの値が変わる
```
実は、レシーバの型が「値型」か「ポインタ型」かどうかで挙動が変わる。
値型とポインタ型のレシーバには、次のような違いがあります。
- 値型
  - メソッド呼び出し時に「レシーバそのもののコピー」が発生する
    - なので、メソッド内でフィールドの値を更新したとしても、これらの変更はコピーに対して行われるため、元の構造体には何の影響も与えられない
- ポインタ型
  - ポインタ型のレシーバを受け取るため、メソッド内部で「実体」に対して変更処理を書くことが可能になる
  - 受け取ったポインタを利用して、メソッドの内部で間接参照を行えば、実際の値 に対して変更を行うことができます。
    - 今回のように構造体そのものを直接操作したい場合は、この方法を利用する必要がある
### このケースでのGo言語の場合
例えば、上記のコードは本来であれば、次のように書くはずです。
```go
func (p *Person) Eat() {
	(*p).weight += 1
}

func main() {
	hanako := Person{"Tanaka Hanako", 25, "female", 50}
	ptrHanako := &hanako // 変数hanakoのポインタを作成
	ptrHanako.Eat()      // ポインタからメソッドの呼び出しを行う
	fmt.Println("食後の体重は", hanako.weight) // => 51
}
```
なぜなら、先ほどはメソッドのレシーバを ポインタ型 に書き換えたので、メソッドを呼び出している変数 hanako も、必然的に ポインタ型 に書き換えるはず、だからです。
- しかし、Go言語の場合はその必要はありません。たとえ呼び出し元の変数がポインタ型じゃなくても、レシーバがポインタ型である場合は Go言語が勝手に判断して、それをポインタ型として解釈してくれます。
  - （もちろん上記のように、呼び出し元の変数を律儀にポインタ型に書き換えたとしても問題はありません。）

逆に、呼び出し元の変数がポインタ型だったとしても、レシーバの型が値型である場合は、値型のレシーバとして自動で解釈してくれます。

















































