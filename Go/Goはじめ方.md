# Goのプロジェクト構成の基本
>[Goのプロジェクト構成の基本](https://zenn.dev/nobonobo/articles/4fb018a24f9ee9)
>[Goプロジェクトのはじめかたとおすすめライブラリ8.5選。ひな形にも使えるサンプルもあるよ。](https://qiita.com/yagi_eng/items/65cd812107362d36ae86)
>[少しずつ育てるGo言語のプロジェクト構成](https://zenn.dev/foxtail88/articles/824c5e8e0c6d82)

# はじめに
1. main.goだけで始める
2. main.goが大きくなったらファイルを分割する
3. 共通するロジックを使って複数のアプリを作る
4. 共通するロジックが大きくなってきたので分割する
5. 共通するロジックを、他の人にも使ってもらうために別モジュールに切り出す
6. マルチモジュールにする

```bash
mkdir <Goプロジェクト名> #最初にプロジェクトフォルダを作成
cd <Goプロジェクト名> #プロジェクトフォルダに移動
```
- この時点でプロジェクトフォルダは空っぽです。
- go mod init <プロジェクト名> でモジュールを宣言し、go.modファイルを作成します。
```zsh
go mod init <プロジェクト名>
```
- 作成するGoモジュールをGithub等で公開する前提であれば、モジュール名はリポジトリのURL形式が推奨されています。
```
go mod init github.com/＜アカウント名＞/go-counter
```
- ここで覚えておく点として、Goにおけるリポジトリ＞モジュール＞パッケージという関係があります。
  - 1リポジトリには複数のモジュールを含められますし、1モジュールには複数のパッケージを含めることができます。


# GOPATHについて
Go1.16がリリースされたことでGo-Moduleによるプロジェクト構成が標準で推奨されることになりました。
- （Go1.11までさかのぼってGo-Moduleは使える様になってます）

Go-Moduleモードでは「GOPATH配下にプロジェクトを置かなければならない」という制約からは解放されています。
- なので、実質GOPATHはどこを指していても構わないし設定されていなくても「ユーザーホーム/go」というデフォルトの場所が決まっているので開発できます。

おすすめの環境変数設定は以下の２つだけ。
- `GOPATH=~/.go`
  - （Windowsは`GOPATH=％USERPROFILE%\.go`）
- `PATH=＄GOPATH/bin:$PATH`
  - （Windowsは`PATH=％GOPATH%\bin;%PATH%`）

!!! warning 初学者はその他のGOXXXX環境変数をいじらないことをお勧めします。goenvやgvmなどのマルチバージョン管理も使わない方が良いと思います。（GOPATHの場所が複数になると開発体験が低下します）

# モジュールとパッケージとは
- モジュール＝パッケージを一つまたは複数のサブパッケージを取りまとめたカタマリ。
- パッケージ＝フォルダ単位で単一ファイルまたは複数ファイルのカタマリ。
- サブパッケージ＝サブフォルダにおくだけで扱いはパッケージと同等。

GOPATHモードの時にはモジュールという概念はなかったんだけど、パッケージとそのサブパッケージをまとめて「モジュール」として扱う概念が追加されたということ。

あるフォルダにてモジュールだと宣言するとそのフォルダ以下がモジュールになります。
宣言方法は以下の通り
```bash
> go mod init <モジュール名>
```
<モジュール名>は`github.com/nobonobo/moduleA`というような表記になります。
- （モジュールを公開しない場合はmoduleAという名前でも良い）

こうするとカレントフォルダにgo.modファイルが作成され、このカレントフォルダ以下がまるっと「モジュール」の扱いになります。

パッケージ名とはパッケージに置かれるGoコードの先頭に宣言される名称で、これは極力そのパッケージのフォルダ名と合致させることが推奨されます。
- モジュール名も、最後の部分パス名（前述の例であればmoduleA）とモジュールのフォルダ名は合致している方が良いと思います。

# ファイル構成例:GitHub公開版
- project1/ :プロジェクトルート＝モジュールルート＝リポジトリルート
  - subpkg1/
    - sub1.go
  - subpkg2/
    - sub2.go
  - app.go
  - go.mod
>go.mod
```go
module github.com/nobonobo/project1

go 1.16
```
>sub1.goの冒頭
```go
package subpkg1
```
>sub2.goの冒頭
```go
package subpkg2
```
以上のような構成の場合、
subpkg1やsubpkg2は"<モジュール名>/subpkg1"や"<モジュール名>/subpkg2"という記述でインポートできます。

>app.goの冒頭
```go
package main

import (
	"github.com/nobonobo/project1/subpkg1"
	"github.com/nobonobo/project1/subpkg2"
)
```

# ファイル構成例:非公開版
ルールは何も変わらない。
- project1/ :プロジェクトルート＝モジュールルート＝リポジトリルート
    - subpkg1/
      - sub1.go
    - subpkg2/
      - sub2.go
  - app.go
  - go.mod

>go.mod
```go
module project1

go 1.16
```
>sub1.goの冒頭
```go
package subpkg1
```
>sub2.goの冒頭
```go
package subpkg2
```
>app.goの冒頭
```go
package main

import (
	"project1/subpkg1"
	"project1/subpkg2"
)
func main() {
   fmt.Println(subpkg.Hello())
   fmt.Println(subpkg.Golang())
   fmt.Println(Goodbye())
}
```
- mainパッケージのmain関数がエントリポイントとなる
  - main.go５行目のようにサブパッケージをインポートする場合、モジュール名をルートディレクトリとしたフルパスで記載する必要があります。
    - （公開しない場合はsubpkgのみで大丈夫です）
- main.go9,10行目のように別のパッケージに属する関数を呼び出す場合はパッケージ名.関数名()で呼び出す必要があリますが、main.go11行目のように同一パッケージの関数の場合は関数名()のみで呼べ出せます。
  - 実は同じパッケージに属するファイルであれば、分割しても同じファイルに記載しても動作的に全く影響はなく（単に読みやすいかや管理しやすいかという問題だけ）、app.goのGoodbye関数をmain.goに定義しても何も動作は変わりません。

## 実行前に外部パッケージのダウンロード
```bash
go mod tidy
```
- go.mod ファイルがソースコードに合っているかを確認する
- ビルドするために必要なモジュールを追加したり、削除したり整理してくれる。
- go.sumにその情報を記載する。


# 複雑な事例
モジュール配下にサブモジュールを置いた場合などもっと複雑な事例はあるけれど、あまり有効なものとは思えないです。基本は「リポジトリ１つ」に「モジュール１つ」です。


## まとめ
>[Goのプロジェクト構成の基本](https://zenn.dev/nobonobo/articles/4fb018a24f9ee9)
- 結構古い読み物を参考にGOPATH配下にプロジェクトを置かなければという誤解が後を絶たない。
- Go-Moduleモードを基本に使っていこう。
- 初心者は環境変数いじらなくてもいいと思う。
- Go-ModuleモードではGOPATHは依存キャッシュとして使われるだけになった。
- gvmやgoenvなどは使わない方がいいよ（DX悪化しちゃう。特にエディタ連携が辛くなる）
- 相対パスインポートを見たらそのコードは古い可能性が高いので参考にしない様に。
- 標準のGoのマルチバージョン利用方法があるよ！
