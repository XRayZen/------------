## ポインタ
>[参考記事](https://zenn.dev/sharefull_blog/articles/1fb628d82ed79b)
- ポインタはメモリ上のアドレスを指し示す変数
### この「メモリアドレス」とは何でしょうか？
- メモリアドレスについて知るには、メモリとは何か知っておく必要があります
  - そしてメモリを知るためには、メモリ周辺の装置についても少しだけ知っておく必要がある
- まずプログラムがストレージに保存されてからCPUで実行されるまでの流れについて、ざっくりと説明
  - そして次に、メモリアドレスとは何かという説明
  - 最後に、具体的なポインタの役割や使い方について解説していきたいと思います。

### ストレージ→メモリ→CPUの流れ
![Alt text](https://storage.googleapis.com/zenn-user-upload/066543edb0a5ae6d05935142.png)

#### ストレージ
- まず、プログラムはストレージに保存されます。
  - ストレージとは、データを永続的に保存するための大容量の記憶装置のことです。
  - 別名「補助記憶装置」とも呼ばれます。
  - メインメモリは揮発性があるので、コンピュータの電源がオフのときは記憶内容を忘れてしまいます。
    - なので、CPUに実行してほしいプログラムなどは、最初に不揮発性であるストレージに保存されるようになっています。
#### メインメモリ
- 次に、プログラムは起動されたタイミングで、ストレージからメインメモリにコピーされます。
- メインメモリは、プログラムやデータを一時的に蓄えておくための装置です。
  - 別名「主記憶装置」とも呼ばれます。
  - プログラムはストレージ上で直接実行されるわけではなく、必要なときに必要な分だけメインメモリにコピーして動作させます。
  - メインメモリ上にはプログラムのコードだけではなく、プログラムが使うデータ（変数）なども保存されます。
#### CPU
- 最後に、プログラムの命令をCPUが1つずつ読み出して実行していきます。
- CPUは Central Processing Unit の略で、コンピューターの中枢部分にあたります。
- CPUがメインメモリにアクセスするときは、自分の足（端子）の一部を使って、『×△の場所にあるデータを僕のXXに送ってくれ！』というような電気信号をメインメモリに送信します。
  - プログラムの命令をメインメモリが読み出したら、CPUがそれを解読して順番に実行していきます。
  - 命令を実行した結果、メインメモリ上のデータを書き変えることもできます。

以上が、メモリ周辺の装置についてのざっくりとした説明

### メモリアドレス
先ほど、CPUがメインメモリにアクセスするときの場所の指定方法として、『×△の場所』というような表現をしました。
- 実は、これが「メモリアドレス」と呼ばれるものです。
  - メインメモリには、1バイトごとに小部屋がぎっしりと並んでいます。
  - 各小部屋には、0番地、1番地、2番地というように、住所の番地のように連続した番号が振られており、これをメモリアドレスと呼びます。
![Alt text](https://storage.googleapis.com/zenn-user-upload/2e69f1d9b8bceeb22a7f3716.png)

プログラム内で変数などが宣言されると、値はこのメインメモリ上の小部屋のどこかに格納されます。
- このときに必要な小部屋の数は、変数の型のサイズに応じて変わります。

例えば、次のような2つの変数が宣言されているプログラムを実行した場合、
```go
var a string = "a"
var num int = 10
```
- 変数 a は string 型で、string 型のデータは半角1文字につき1バイトのサイズを持つので、小部屋は1つだけ割り当てられます。
- 変数 num は int 型で、int 型のデータは4バイトのサイズを持つので、4つの小部屋が割り当てられます。

![Alt text](https://storage.googleapis.com/zenn-user-upload/944b0418c3eba1264d60865d.png)

- 図では、変数 a には 100 番、変数 num には 101〜104 番のメモリアドレスが割り当てられていますが、連続した領域（小部屋）が割り当てられている場合は、先頭のアドレスが代表として用いられることになっています。
  - なので、この場合の変数 num のメモリアドレスは 101 番となります。

また、実際のメモリアドレスはコンパイル時に自動で割り振られるので、どの変数がどのメモリアドレスになるかは分かりません。
- しかし、次に述べる方法を使えばメモリアドレスは簡単に調べることができます。

### 変数のメモリアドレスを取得する
その方法とは、変数名の前に & ( アドレス演算子 ) という記号を付けるだけです。
```go
&変数名
```
上記のような書き方で、メモリアドレスの取得ができます。
- では、実際に変数 a と num のメモリアドレスを調べてみましょう。

>メモリアドレスを調べる
```go
fmt.Println(&a)   // => 0xc00010a210
fmt.Println(&num) // => 0xc000126000
```
ここでは「0xc00010a210」と「0xc000126000」が表示されました。（この値は実行環境によって異なります）
- 頭の「0x（ゼロエックス）」という記号は、この値が 16進数であること示します。
  - Go言語やC言語などでは、16進数を扱うときはこの接頭辞を付けることで、2進数・8進数・10進数などから16進数をすぐに判別できるようにしています。
  - 先ほどの図では、分かりやすさ重視のためメモリアドレスは10進数で表していましたが、通常メモリアドレスはこのように16進数で表示されます。

また、メモリアドレスは 16進数で書かれていようが 10進数で書かれていようが、値はただの数値です。
- 単なる数値なら、変数に入れることもできる

次は取得したメモリアドレスを変数に格納してみましょう。
### ポインタ変数の宣言
変数 a のメモリアドレスを格納するための変数を作ってみましょう。
コードは次のように書きます。
```go
var ptrA *string = &a
```
* 上記のコードにある *string については、別途「ポインタ変数に型を付けよう」で解説します。

ptrA には、変数 a のメモリアドレスが格納されています。
- 実はこの ptrA のように、「メモリアドレスを入れることのできる変数」のことを「ポインタ変数」と呼びます。

なぜこれがポインタ変数と呼ばれるのでしょうか。

### ポインタとは
ポインタという単語は「指し示すもの」という意味があります。
ではこの変数 ptrA は、一体何を指し示しているか？

ポインタの意味を探ってみると「物を指し示すために使われるもの」ということ
- 例えば、レーザーポインタやマウスポインタ

##### Go言語におけるポインタはデータを格納したある特定のメモリアドレスを指し示す
先ほど、変数 a のメモリアドレス格納する変数 ptrA を作成しました。
```go
var ptrA *string = &a
```
>これを図で表すと、次のようなイメージになります
![Alt text](https://storage.googleapis.com/zenn-user-upload/31eafb48681b-20211220.png)

まとめると、ポインタ変数は次の特徴を持った変数であると言うことができます。
- 変数のメモリアドレスを格納する
- 格納したメモリアドレスを指し示す役割を持つ

ただ、これだけしかできないのであればポインタ変数の役割は皆無に近いですよね。

### 間接参照
#### 次は、ポインタ変数を使って実際に私たちができることについて
現実の世界では、住所が分かれば、その家を訪問することができます。
- メモリの世界でも同様に、変数の住所（メモリアドレス）さえ特定できれば、そこにある変数の中を覗いたりすることができるようになります。

変数の中を覗きに行くためには、変数の住所を格納しているポインタ変数の存在が必要不可欠です。
- しかしポインタ変数というのは、基本的にメモリアドレスを指し示すことだけを仕事としているので、「覗きにいく」という行為をやってもらうためには、プログラマがそのような指示をポインタ変数に与える必要があります。
  - 現実世界で例えるならば、ポインタ変数は住所が書かれたメモ用紙をずっと持っているだけの人なので、何かをして欲しければ、ポインタ変数に何かを命じなければならない
#### では具体的にどうやって指示を与えればいいのでしょうか
その方法とは、ポインタ変数名の前に *（アスタリスク・間接参照演算子）を付けるだけです。
```go
*ポインタ変数名
```
ポインタ変数名の前に * という記号を付けることで「そのポインタ変数が指しているメモリの内容を参照しろ」というような意味になります。
- また実際の変数名そのものではなく、ポインタ変数を介して値を参照するということを「間接参照」と呼びます。

では、実際に間接参照を使って、変数 a の値を覗き見してみましょう。
```go
a := "a"
ptrA := &a

fmt.Println(ptrA)  // => "0xc00010a210"
fmt.Println(*ptrA) // => "a"
```
上記のプログラムでは、まず変数 a に文字列 "a" を入れて変数宣言した後、それを変数 ptrA の中に格納してポインタ変数を作成しています。
- その後、*（間接参照演算子）を用いて ptrA が指し示すメモリアドレスに入っている変数の値、つまり変数 a の値を取得しています。
  - fmt.Println により表示される値は "a" となるはずです。

このように、ポインタ変数に対して間接参照を使うと、変数の中身を覗きに行くことが可能になります。

それだけではありません。間接参照を使えば、変数の中の値を書き換えることもできます。
![Alt text](https://storage.googleapis.com/zenn-user-upload/298d71056ede94c4136762da.png)

例えば次のコードでは、 ポインタ変数の作成後に、そのポインタ変数が指し示すメモリアドレスの変数の値を "b" という値に上書きしています。
```go
a := "a"
ptrA := &a

*ptrA = "b"           // 間接参照を使って変数ptrAの値を"b"に変更する
fmt.Println(*ptrA)    // => "b"
```
このように間接参照を使えば、値を参照するだけではなく、ポインタ変数が指すメモリアドレスに別の値を代入することも可能となるのです。

### ポインタ変数に型を付ける(ポインタ型について)
Go言語でポインタ変数を宣言するときは、型名の前に * を付ける必要があります。
- こうすることで「ポインタ型」の変数として宣言することができます。

構文
```go
var 変数名 *型
```
この * の後ろには、ポインタが指し示す変数と同じデータ型を記します。
- 例えば、ポインタが int 型の変数を指し示す場合、ポインタ型は *int になります。
    ```go
    var i int = 10
    var ptrI *int = &i
    ```
ポインタ変数は *int 型であっても *string 型であっても、サイズは大体4バイトか8バイトのどちらかになります。
- （32ビットOSなら前者で64ビットOSなら後者）

!!! note つまり、ポインタ変数が指し示す先の変数の型が異なっていても、ポインタ変数自体のサイズはどれも同じということです。

試しに unsafe.Sizeof を使って、異なるポインタ型のサイズをそれぞれ調べてみましょう。すると、どちらも同じサイズという結果になります。
```go
var i int = 10
var ptrI *int = &i
fmt.Println(unsafe.Sizeof(ptrI)) // => 8

var s string = "Hello"
var ptrS *string = &s
fmt.Println(unsafe.Sizeof(ptrS)) // => 8
```
!!! question では、ポインタ変数自体のサイズがすべて同じならば、ポインタ変数が指し示す先の変数のデータ型をわざわざ指定しなければならない理由とは
    「何型」のアドレスなのか指定してないと、間接参照を使って変数の値を読み書きするとき、何バイトまで辿ればいいのかわからなくなってしまうから

    というのも、ポインタ変数が指し示すメモリアドレスは先頭のメモリアドレスだけ
    そのメモリアドレスから何バイトのデータがあるかは型によって異なるため、何型かの情報がなければ、そのデータにアクセスすることができなくなってしまう

!!! info したがって、このようなことを避けるため、ポインタ変数には明示的にその指し示す型を指定する必要があるのです。





















































































































